<!DOCTYPE html>
<meta charset="utf-8">
<head><link href="nouislider.min.css" rel="stylesheet"></head>
<style>

svg {
    position: relative;
    left: 0;
    top: 0;
    z-index: -1;
}

#legend {
    position: fixed;
    right: 0;
    top: 0;
    z-index: -1;
}

.legend {
    font: 6px sans-serif;
  }

.control-group {
	position: fixed;
	width: 9%;
    left: 5%;
    padding-top: 2%;
}

#container {
	z-index: 1;
    position: fixed;
    left: 0;
    right: 0;
    top: 0;  
    height: 40%;
    background:rgba(63,184,175,0.25);	
}
    
#slider {
    position: fixed;
	width: 69%;
    right: 5%;
    margin: 5% 0px 0px 0px;
}

.example-val-1 {
	position : fixed;
    font: 400 12px Arial;
    color: #888;
    display: block;
    right: 5%;
    margin: 13% 0% 0px 10%;	
}

.example-val-mid {
	position : fixed;
    font: 400 12px Arial;
    color: #888;
    display: block;
    right: 5%;
    margin: 11.5% 0% 0px 10%;	
}

.example-val-2 {
	position : fixed;
    font: 400 12px Arial;
    color: #888;
    display: block;
    right: 5%;
    margin: 10% 0% 0px 10%;	
}

/* From http://bost.ocks.org/mike/style.css?20120427 */
 
@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
 
html {
min-width: 1040px;
}
 
body {
background: #fcfcfa;
color: #333;
font-family: "PT Serif", serif;
margin: 1em auto 4em auto;
position: relative;
width: 100%;
}
 
header,
footer,
h1,
h2,
h3,
h4,
aside {
color: #000;
font-family: "PT Sans", sans-serif;
}
 
h1 {
font-size: 64px;
font-weight: 300;
letter-spacing: -2px;
margin: .3em 0 .1em 0;
}
 
h2 {
margin-top: 2em;
}
 
h1, h2 {
text-rendering: optimizeLegibility;
}
 
h2 a {
color: #ccc;
left: -20px;
position: absolute;
width: 740px;
}
 
footer {
font-size: small;
margin-top: 8em;
}
 
header aside {
margin-top: 88px;
}
 
header aside,
footer aside {
color: #636363;
text-align: right;
}
 
aside {
font-size: small;
left: 0;
position: absolute;
width: 180px;
}
 
.attribution {
font-size: small;
margin-bottom: 2em;
}
 
body > p, li > p {
line-height: 1.5em;
}
 
body > p {
width: 720px;
}
 
body > blockquote {
width: 640px;
}
 
blockquote q {
display: block;
font-style: oblique;
}
 
li {
width: 680px;
}
 
a {
color: steelblue;
}
 
a:not(:hover) {
text-decoration: none;
}
 
pre, code, textarea {
font-family: "Menlo", monospace;
}
 
code {
line-height: 1em;
}
 
textarea {
font-size: 100%;
}
 
body > pre {
border-left: solid 2px #ccc;
padding-left: 18px;
margin: 2em 0 2em -20px;
}
 
.html .value,
.javascript .string,
.javascript .regexp {
color: #756bb1;
}
 
.html .tag,
.css .tag,
.javascript .keyword {
color: #3182bd;
}
 
.comment {
color: #636363;
}
 
.html .doctype,
.javascript .number {
color: #31a354;
}
 
.html .attribute,
.css .attribute,
.javascript .class,
.javascript .special {
color: #e6550d;
}
 
svg {
font: 8px sans-serif;
}
 
.axis path, .axis line {
fill: none;
stroke: #000;
shape-rendering: crispEdges;
}
 
sup, sub {
line-height: 0;
}
 
q:before {
content: "â€œ";
}
 
q:after {
content: "â€";
}
 
blockquote:before {
position: absolute;
left: 2em;
}
 
blockquote:after {
position: absolute;
}


.ticks {
  font: 10px sans-serif;
}

.track,
.track-inset,
.track-overlay {
  stroke-linecap: round;
}

.track {
  stroke: #000;
  stroke-opacity: 0.3;
  stroke-width: 10px;
}

.track-inset {
  stroke: #ddd;
  stroke-width: 8px;
}

.track-overlay {
  pointer-events: stroke;
  stroke-width: 50px;
  cursor: crosshair;
}

.handle {
  fill: #fff;
  stroke: #000;
  stroke-opacity: 0.5;
  stroke-width: 1.25px;
}


</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="nouislider.min.js"></script>
<div id="container">
	<div id="slider"></div>
	<span class="example-val-1" id="slider-value-lower">20.00</span>
	<span class="example-val-mid">to</span>
	<span class="example-val-2" id="slider-value-upper">20.00</span>
	<svg id="legend"></svg>
	<div class="control-group"> 
		<button onclick="select('all')">
			All Countries
		</button>
		<button onclick="select('de')">
			Germany
		</button>
		<button onclick="select('en-us')">
			United States
		</button>
		<button onclick="select('en-gb')">
			Britain
		</button>
		<button onclick="select('el-gr')">
			Greece (Greek)
		</button>
		<button onclick="select('el')">
			Greece (English)
		</button>
		<button onclick="select()">
			Clear
		</button>
		<button onclick="mode(false)">
			Time Scale
		</button>
		<button onclick="mode(true)">
			Percentage Scale
		</button>
	</div>

</div>

<svg id="chart"></svg>


<script>

var category = "all";

var absolute = true;

var width = window.innerWidth*3,
    height = window.innerHeight*5,
    legendSpacing = 9,
    legendRectSize = 9;

var margin = {top: width/10, right: width/30, bottom: width/30, left: width/15},
    width = width - margin.left - margin.right,
    height = height - margin.top - margin.bottom;
    
var svg = d3.select("#chart")
.attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", 
          "translate(" + margin.left + "," + margin.top + ")");
          
var svglegend = d3.select("#legend")
.attr("width", width/30 + margin.left + margin.right)
    .attr("height", height/30 + margin.top + margin.bottom)
  .append("g")
    .attr("transform", 
          "translate(" + margin.left + "," + margin.top + ")");         

var color = d3.scaleOrdinal(d3.schemeCategory20); //more scales here :https://github.com/d3/d3-scale/blob/master/README.md#category-scales
        
var slider = document.getElementById('slider');

var timeStamp = Math.floor(Date.now() / 1000); 
var startDate = 1483000000;

var timeLimits = [startDate, timeStamp];

noUiSlider.create(slider, {
	start: timeLimits,
	connect: true,
	range: {
		'min': startDate,
		'max': timeStamp
	}
});

var sliderValues = [
	document.getElementById('slider-value-lower'),
	document.getElementById('slider-value-upper')
];

slider.noUiSlider.on('update', function( values, handle ) {
	sliderValues[handle].innerHTML = timeConverter(values[handle]);
	timeLimits = values;
	render();
});

function getIndex(link, nodes){
	var index = -1;
	nodes.forEach(function(d, i) {
        if (link == d.id){
        	index = i;
        }
     });
     return index;
}	

var legendValues;

function getLegendValues(nodes){
	legendValues = new Array();
	nodes.forEach(function(d, i) {
		index = -1;
		legendValues.forEach(function(ld, j) {
        if (ld.event == d.event){
        	index = j;
        }});
        if (index == -1){
        	//found an event missing from legendValues!
        	legendValues.push({event:nodes[i].event});
        }
     });
     return index;
}

function timeConverter(UNIX_timestamp){
  var a = new Date(UNIX_timestamp * 1000);
  // var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
//   var year = a.getFullYear();
//   var month = months[a.getMonth()];
//   var date = a.getDate();
//   //var hour = a.getHours();
//   //var min = a.getMinutes();
//   //var sec = a.getSeconds();
//   var time = date + ' ' + month + ' ' + year;
//   //var time = date + ' ' + month + ' ' + year + ' ' + hour + ':' + min + ':' + sec ;
  return a;
}

function render(){
	if (absolute)
		renderAbsolute();    
	else renderRelative(); 
}

function renderAbsolute() {

	d3.text("https://dl.dropbox.com/s/4t0oo4g14aalhpo/combined.json?dl=1", function(error, text) {
     if (error) throw error;
	svg.selectAll("*").remove();
        text = text.substring(0, text.length - 1);     //remove final comma            
        text = "[" + text.replace(/(?:\r\n|\r|\n)/g, ',\n') + "]"; //convert to full JSON format
    
		var data = JSON.parse(text);
        //var data = orderByOccurrence(gameData);
            
		//Convert links to a timeline data structure
		//we want an array of the following: 
		//event: "", times:[{"starting_time":num, "ending_time":num}]
		
		//we assume that the data is ordered by user and chronologically
		
		var graph = new Array();
		var playthrough_id;
		var session_starting_time;
		var session_ending_time;
		
		for (var i = 0; i < data.length; i++) { 	               
            if ((category == "all") || (category.toLowerCase() == data[i].locale.toLowerCase()	)) {
				if ((+data[i].ts < +timeLimits[1]) && (+data[i].ts > +timeLimits[0])){
				//assumes that the first event in the log of playtraces is a Launch event
					if ((i > 0) && (data[i-1].user_id == data[i].user_id )){
						if (data[i].event != "launch"){
							//starting from second event, calculate the start and end times of preceding event								
							//IMPORTANT: Ignores final event! We don't know the duration of this.
							if (data[i-1].event == "launch"){
								playthrough_id++; //treat every 'launch' event as the start of a new game
								session_starting_time = timeConverter(data[i-1].ts);
							}	
							var id = data[i-1].user_id + ", game "+playthrough_id;
							var event = data[i-1].event;
							var starting_time = timeConverter(+data[i-1].ts);
							var ending_time = timeConverter(+data[i].ts);
							session_ending_time = ending_time;
							var times = {starting_time, ending_time, session_starting_time, session_ending_time};
							graph.push({
								id: id,
								event: event,
								times: times
							});
						}
						else {
							//current event is Launch, start new session
							session_starting_time = timeConverter(data[i].ts);
						}
					}
					else {
						playthrough_id = 0; //reset current player's game
						session_starting_time = timeConverter(data[i].ts); //mark the time when player starts a playthrough
					}			
				}
			}
        }
        
        //update session ending variables
        for (var i = graph.length - 1; i >= 0; i--){ 
			if (i == (graph.length - 1) ){
				//safely assume that a session has ended!
				graph[i].times.session_ending_time == graph[i].times.ending_time;
			}
			else if (graph[i].times.session_starting_time == graph[i+1].times.session_starting_time){
				//if two events have the same session start time, they must have the same session end time
				//that's how sessions work					
				graph[i].times.session_ending_time = graph[i+1].times.session_ending_time;
			}
			else {
				graph[i].times.session_ending_time = graph[i].times.ending_time;
			}
		}
							
        getLegendValues(graph); //prepare the data to create a legend
        
		// set the ranges
		var y = d3.scaleBand()
				  .range([height, 0])
				  .padding(0.2);

		var x = d3.scaleLinear()
				  .range([0, width]);
		  
		     // Scale the range of the data in the domains
	  //x.domain([0, d3.max(graph, function(d){return d.times.ending_time - d.times.session_starting_time})]) //measure the length of each playthrough
	  x.domain([0.0, 1.0]) //measure the length of each playthrough
	  
	 // var max = d3.max(graph, function(d){return d.times.ending_time - d.times.session_starting_time});
	  
	  y.domain(graph.map(function(d) { return d.id; }));
	  
	  svglegend.selectAll("*").remove();
	  
	  var legend = svglegend.selectAll(".legend")
		  .data(legendValues)
		  .enter()
		  .append('g')
		  .attr('class', 'legend')
		  .attr('transform', function(d, i) {
			var height = legendRectSize + legendSpacing;
			var offset =  5 * height;
			var horz = -7 * legendRectSize;
			var vert = i * height - 2* offset - 180;
			return 'translate(' + horz + ',' + vert + ')';
		  });	
  
	  legend.append('rect')
	  .attr('width', legendRectSize)
	  .attr('height', legendRectSize)
	  .style('fill', function(d) { return color(d.event); })
	  .style('stroke', function(d) { return color(d.event); }); 
  
	  legend.append('text')
	  .attr('x', legendRectSize + legendSpacing)
	  .attr('y', 8 + legendRectSize - legendSpacing)
	  .text(function(d) { return d.event; });
	  
	  // append the rectangles for the bar chart
	  svg.selectAll(".bar")
		  .data(graph)
		.enter().append("rect")
		  .attr("class", "bar")
		  //.attr("x", function(d) { return x(d.times.starting_time - d.times.session_starting_time); })
		  .attr("x", function(d) {return x((d.times.starting_time - d.times.session_starting_time)/(d.times.session_ending_time-d.times.session_starting_time)); })
		  .attr("width", function(d) {
		  	var a = x((d.times.starting_time - d.times.session_starting_time)/(d.times.session_ending_time-d.times.session_starting_time));
		  	var b = x((d.times.ending_time - d.times.session_starting_time)/(d.times.session_ending_time-d.times.session_starting_time));
		  	return b - a;}
		  	)
		  .attr("y", function(d) { return y(d.id);})
		  .attr("fill", function(d) { return color(d.event); })
		  .attr("user", function(d) { return d.id; })
		  .attr("height", y.bandwidth());
	
	 // add the x Axis
	  svg.append("g")
		  .attr("transform", "translate(0," + height + ")")
		  .call(d3.axisBottom(x)	  	  	
		  	.ticks(20));
		  	//.tickFormat(d3.timeFormat('%Hhours-%Mmin-%Ss')));
		  	
	  // add the y Axis
	  svg.append("g")
		  .call(d3.axisLeft(y));
	});
}

function renderRelative() {

	d3.text("https://dl.dropbox.com/s/4t0oo4g14aalhpo/combined.json?dl=1", function(error, text) {
     if (error) throw error;
	svg.selectAll("*").remove();
        text = text.substring(0, text.length - 1);     //remove final comma            
        text = "[" + text.replace(/(?:\r\n|\r|\n)/g, ',\n') + "]"; //convert to full JSON format
    
		var data = JSON.parse(text);
        //var data = orderByOccurrence(gameData);
            
		//Convert links to a timeline data structure
		//we want an array of the following: 
		//event: "", times:[{"starting_time":num, "ending_time":num}]
		
		//we assume that the data is ordered by user and chronologically
		
		var graph = new Array();
		var playthrough_id;
		var session_starting_time;
		
		for (var i = 0; i < data.length; i++) { 	               
            if ((category == "all") || (category.toLowerCase() == data[i].locale.toLowerCase()	)) {
				if ((+data[i].ts < +timeLimits[1]) && (+data[i].ts > +timeLimits[0])){
				//assumes that the first event in the log of playtraces is a Launch event
					if ((i > 0) && (data[i-1].user_id == data[i].user_id )){
						if (data[i].event != "launch"){
							//starting from second event, calculate the start and end times of preceding event								
							//IMPORTANT: Ignores final event! We don't know the duration of this.
							if (data[i-1].event == "launch"){
								playthrough_id++; //treat every 'launch' event as the start of a new game
								session_starting_time = timeConverter(data[i-1].ts);
							}	
							var id = data[i-1].user_id + ", game "+playthrough_id;
							var event = data[i-1].event;
							var starting_time = timeConverter(+data[i-1].ts);
							var ending_time = timeConverter(+data[i].ts);
							var times = {starting_time, ending_time, session_starting_time};
							graph.push({
								id: id,
								event: event,
								times: times
							});
						}
						else {
							//current event is Launch, start new session
							session_starting_time = timeConverter(data[i].ts);
						}
					}
					else {
						playthrough_id = 0; //reset current player's game
						session_starting_time = timeConverter(data[i].ts); //mark the time when player starts a playthrough
					}			
				}
			}
        }
        
        getLegendValues(graph);
        
		// set the ranges
		var y = d3.scaleBand()
				  .range([height, 0])
				  .padding(0.2);

		var x = d3.scaleLinear()
				  .range([0, width]);
		  
		     // Scale the range of the data in the domains
	  //x.domain([d3.min(graph, function(d){return d.times.starting_time}), d3.max(graph, function(d){ return d.times.ending_time})])
	  x.domain([0, d3.max(graph, function(d){return d.times.ending_time - d.times.session_starting_time})]) //measure the length of each playthrough
	  y.domain(graph.map(function(d) { return d.id; }));
	  
	  svglegend.selectAll("*").remove();
	  
	  var legend = svglegend.selectAll(".legend")
		  .data(legendValues)
		  .enter()
		  .append('g')
		  .attr('class', 'legend')
		  .attr('transform', function(d, i) {
			var height = legendRectSize + legendSpacing;
			var offset =  5 * height;
			var horz = -7 * legendRectSize;
			var vert = i * height - 2* offset - 180;
			return 'translate(' + horz + ',' + vert + ')';
		  });	
  
	  legend.append('rect')
	  .attr('width', legendRectSize)
	  .attr('height', legendRectSize)
	  .style('fill', function(d) { return color(d.event); })
	  .style('stroke', function(d) { return color(d.event); }); 
  
	  legend.append('text')
	  .attr('x', legendRectSize + legendSpacing)
	  .attr('y', 8 + legendRectSize - legendSpacing)
	  .text(function(d) { return d.event; });
	  
	  // append the rectangles for the bar chart
	  svg.selectAll(".bar")
		  .data(graph)
		.enter().append("rect")
		  .attr("class", "bar")
		  .attr("x", function(d) { return x(d.times.starting_time - d.times.session_starting_time); })
		  .attr("width", function(d) {w = x(d.times.ending_time - d.times.starting_time);  /*if (w<1) w=1;*/ return w; } )
		  .attr("y", function(d) { return y(d.id);})
		  .attr("fill", function(d) { return color(d.event); })
		  .attr("user", function(d) { return d.id; })
		  .attr("height", y.bandwidth());
	
	 // add the x Axis
	  svg.append("g")
		  .attr("transform", "translate(0," + height + ")")
		  .call(d3.axisBottom(x)	  	  	
		  	.ticks(20)
		  	.tickFormat(d3.timeFormat('%Hhours-%Mmin-%Ss')));
		  	
	  // add the y Axis
	  svg.append("g")
		  .call(d3.axisLeft(y));
	});
}

function select(c) { //ref:https://bl.ocks.org/fabiomainardi/00fd581dc5ba92d99eec
	category = c;
	render();     
}

function mode(c) { //ref:https://bl.ocks.org/fabiomainardi/00fd581dc5ba92d99eec
	absolute = c;
	render();
}


</script>
